#!/usr/bin/perl -w

# Sat Oct 29 01:47:21 EDT 2011
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

our $CJ_GIT_PATCHTOOL_BASEDIR= $ENV{CJ_GIT_PATCHTOOL_BASEDIR}
  or die "must be run from cj-git-patchtool shell";

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname commit(s)

  Like cherry-pick (or actually *does* first try with cherry-pick),
  but creates a patch file with the given commit(s), moves it (them)
  to the patch dir ('$CJ_GIT_PATCHTOOL_BASEDIR'), adds and commits
  them there, then applies them with wig [if git am doesn't work].

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;

use Chj::Git::Functions ":all";
use Chj::xperlfunc ":all";

sub reset_hard {
    my ($gitdir)=@_;
    xgit_do "reset","--hard"; #still assumes cwd in git repo
    $gitdir||=".git"; ##
    my $d= "$gitdir/rebase-apply";
    xxsystem "trash",$d if -e $d;
}

sub xgit_do_hack_reset;
*xgit_do_hack_reset=
  make_xgit_do_hack (sub {
			 my ($gitdir)=@_;
			 reset_hard ($gitdir);
			 git_wait_lock $gitdir;
		     });


# hm get patch file incl name, sigh, we had this once didn't we ?
# ah:
#xxsystem "g-format-patches", "--targetdir", ..., '--', @commits;
#eh but odd, now i'm going to write a --print option but git format-patch already prints it? duh.

use Chj::Xbacktick;
use Chj::Chomp;

## move to a lib? (already copy from cj-git-patchtool, basically)
sub max_number_in {
    my ($glob,$bn_re)=@_;
    my $m=-1;
    for (glob $glob) {
	my $bn=basename $_;
	if ($bn=~ m/$bn_re/) {
	    my $n=$1;
	    if ($n > $m) {
		$m= $n
	    }
	}
    }
    $m+0
      # decimal
}
##/

my $last_patchno=
  max_number_in ("max_number_in$CJ_GIT_PATCHTOOL_BASEDIR/????-*",
		 qr/^(\d{4})-/);
sub next_patchno_str {
    $last_patchno++;
    sprintf("%04d",$last_patchno)
}

# hm check whether status is clean, we've had this, too, right?
Xbacktick "git", "status";
#hmm ?


#our @targetpaths;
our  @targets;

sub pick {
    my ($commit)=@_;
    # first try:
    if (eval {
	xgit_do_hack_reset "cherry-pick", $commit;
    }) {
	# ok done
    } else {
	reset_hard;

	# get patch file incl path:
	my $path= Chomp Xbacktick "git","format-patch", $commit."^..".$commit;
	my $fn= basename $path;
	my $no= next_patchno_str;
	$fn=~ s/^\d{4}-/$no-/;
	my $targetpath= "$CJ_GIT_PATCHTOOL_BASEDIR/$fn";
	xlinkunlink $path, $targetpath;

	push @targets, [$commit,$fn,$targetpath];
    }
}

pick $_ for @ARGV;

sub commit {
    my ($prefix, @targets)=@_;
    if (my $pid= xfork) {
	xxwaitpid $pid,0;
    } else {
	xchdir $CJ_GIT_PATCHTOOL_BASEDIR;

	xgit_do "add", map { $$_[1]} @targets;

	# usually single line, so?:
	my $msg= join ("", map {"$prefix $_\n"}
		       map { "$$_[0] = $$_[1]"} @targets);
	xgit_do "commit", "-m", $msg,
	  map { $$_[1]} @targets;

	exit 0;
    }
}

commit "pick", @targets
  if @targets;

sub apply {
    my ($target)=@_;
    my ($commit,$fn,$targetpath)=@$target;
    if (eval {
	xgit_do_hack_reset "am", $targetpath;
	1
    }) {
	# well, "am" succeeded, what do we want more.
    } else {
	my $e=$@;
	#if ($e=~ )
	#well, it failed, that's enough isn't it ?
	#so, try wig now,
	xxsystem "wig", $fn;
	# so, wig succeeded, commit again
	commit "wig", $target;
	# and, apply it, now that it should apply cleanly
	reset_hard;
	xgit_do_hack_reset "am", $targetpath;
    }
}

# hmm  how can i apply all of them? wll abort on first error.

apply $_ for @targets;

print "\nOk.\n";
